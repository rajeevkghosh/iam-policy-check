#This policy uses the Sentinel tfplan/v2 import to require that
# all GCE compute instances have all mandatory labels

# Note that the comparison is case-sensitive but also that GCE labels are only
# allowed to contain lowercase letters, numbers, hypens, and underscores.

# Import tfplan-functions.sentinel
# with alias "plan"
import "tfplan-functions" as plan
import "strings"
import "types"

prefix = ["us-"]
multi_region_var = ["US"]

# Resource Types Region Map

resourceTypesIamMap = {

	"google_project_iam_policy": {
		"key1":   "policy_data",
        #"key2":   "members",
	},
	"google_project_iam_binding": {
		"key1":   "member",
        "key2":   "members",
	},
	"google_project_iam_member": {
		"key1":   "member",
        "key2":   "members",
	},
    "google_organization_iam_policy": {
		"key1":   "policy_data",
        #"key2":   "members",
	},
    "google_organization_iam_binding": {
		"key1":   "member",
        "key2":   "members",
	},
    "google_organization_iam_member": {
		"key1":   "member",
        "key2":   "members",
	},
}

allResources = {}
for resourceTypesIamMap as rt, _ {
	resources = plan.find_resources(rt)
	for resources as address, rc {
		allResources[address] = rc
	}
}

#print (allResources)

string_handler = func(member) {
	users = []
	a = strings.split(member,"\"")
	#print(a)
	#print(types.type_of(a))
    
	for a as rt {
		#print(rt)
		#print(types.type_of(rt))
		
		if strings.has_prefix(rt, "user") or strings.has_prefix(rt, "group") or strings.has_prefix(rt, "serviceAccount") {
        append(users, rt)

		}
	}
	return users

}

#is_undefined = rule { types.type_of(location) is "undefined" }
check_for_location = func(address, rc, key1, key2) {
	violations = {}
	users = []
	member = plan.evaluate_attribute(rc.change.after, key1)
	#print(member)
	print(types.type_of(member))

	is_string = rule { types.type_of(member) is "string" } 
	if is_string {
		ab = string_handler(member)
	}
	/*
	a = strings.split(member,"\"")
	#print(a)
	#print(types.type_of(a))
    
	for a as rt {
		#print(rt)
		#print(types.type_of(rt))
		
		if strings.has_prefix(rt, "user") or strings.has_prefix(rt, "group") or strings.has_prefix(rt, "serviceAccount") {
        append(users, rt)

		}
	}

    #append(users, member)
    #members = plan.evaluate_attribute(rc.change.after, key2)
    #append(users, members)
	#print(members)

    #print(users)
	*/

    return(users)



}

msgs = {}
for allResources as address, rc {
	msg = check_for_location(
		address,
		rc,
		resourceTypesIamMap[rc["type"]]["key1"],
        resourceTypesIamMap[rc["type"]]["key2"],
	)
	#print(msg)
	if length(msg) > 0 {
		msgs[address] = msg
	}
}


GCP_RES_LOCATION = rule { length(msgs) is 0 }

# Main rule
main = rule { true }